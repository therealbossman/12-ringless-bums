
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>11 Ringless Bums - Power Rankings</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <h1>11 Ringless Bums</h1>

    <div class="toggle-container">
        <button id="playersOnlyBtn" class="toggle-btn active">Players Only</button>
        <button id="playersAndPicksBtn" class="toggle-btn">Players + Picks</button>
    </div>

    <div id="rankings">Loading rankings...</div>

    <script>
        async function fetchKTCValues() {
            return {
                "Patrick Mahomes": 9200,
                "Malik Nabers": 6500,
                "Sam LaPorta": 6000,
                "2025 1st": 5800,
                "2025 2nd": 1400,
                "2026 1st": 5500
            };
        }

        async function fetchSleeperLeagueData() {
            const leagueId = "1182477393715769344";
            const usersResponse = await fetch(`https://api.sleeper.app/v1/league/${leagueId}/users`);
            const rostersResponse = await fetch(`https://api.sleeper.app/v1/league/${leagueId}/rosters`);

            const users = await usersResponse.json();
            const rosters = await rostersResponse.json();

            const userMap = {};
            users.forEach(user => {
                userMap[user.user_id] = user.display_name;
            });

            return { users: userMap, rosters };
        }

        async function buildRankings(includePicks) {
            const ktcValues = await fetchKTCValues();
            const { users, rosters } = await fetchSleeperLeagueData();

            const rankings = rosters.map(roster => {
                let totalValue = 0;
                (roster.players || []).forEach(playerId => {
                    const playerName = playerId;
                    if (ktcValues[playerName]) {
                        totalValue += ktcValues[playerName];
                    }
                });

                if (includePicks && roster.metadata && roster.metadata.picks) {
                    roster.metadata.picks.forEach(pick => {
                        if (ktcValues[pick]) {
                            totalValue += ktcValues[pick];
                        }
                    });
                }

                return {
                    owner: users[roster.owner_id] || "Unknown Owner",
                    value: totalValue
                };
            });

            rankings.sort((a, b) => b.value - a.value);
            return rankings;
        }

        function renderRankings(rankings) {
            const rankingsDiv = document.getElementById('rankings');
            rankingsDiv.innerHTML = '';

            rankings.forEach((team, index) => {
                const div = document.createElement('div');
                div.className = 'team-card';
                div.innerHTML = `
                    <div class="team-rank">#${index + 1} ${index === 0 ? '🏆' : index === 1 ? '🥈' : index === 2 ? '🥉' : ''}</div>
                    <div class="team-owner">${team.owner}</div>
                    <div class="team-value">Total Value: ${team.value}</div>
                `;
                rankingsDiv.appendChild(div);
            });
        }

        async function init(includePicks) {
            const rankings = await buildRankings(includePicks);
            renderRankings(rankings);
        }

        document.getElementById('playersOnlyBtn').addEventListener('click', () => {
            document.getElementById('playersOnlyBtn').classList.add('active');
            document.getElementById('playersAndPicksBtn').classList.remove('active');
            init(false);
        });

        document.getElementById('playersAndPicksBtn').addEventListener('click', () => {
            document.getElementById('playersOnlyBtn').classList.remove('active');
            document.getElementById('playersAndPicksBtn').classList.add('active');
            init(true);
        });

        init(false);
    </script>
</body>
</html>
